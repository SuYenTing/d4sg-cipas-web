# -*- coding: utf-8 -*-
"""drawnetwork.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16EuPwvl6mbzqEVPwP7ssM01dyztPQo05
"""

import pandas as pd
import re, itertools
import networkx as nx
'''
# Colab 進行matplotlib繪圖時顯示繁體中文
# 下載台北思源黑體並命名taipei_sans_tc_beta.ttf，移至指定路徑
!wget -O TaipeiSansTCBeta-Regular.ttf https://drive.google.com/uc?id=1eGAsTN1HBpJAkeVM57_C7ccp7hbgSz3_&export=download

import matplotlib as mpl
import matplotlib.pyplot as plt 
from matplotlib.font_manager import fontManager

# 改style要在改font之前
# plt.style.use('seaborn')  

fontManager.addfont('TaipeiSansTCBeta-Regular.ttf')
mpl.rc('font', family='Taipei Sans TC Beta')
plt.rcParams['font.sans-serif'] = ['Taipei Sans TC Beta']
'''
def get_type():
  in_type = input("請輸入主題分類: 全部、中國國民黨、中華救助總會、婦聯會、救國團、民眾服務社、中央日報社、三中案、革實院、黨營事業、世亞盟、松山油漆廠")
  type_list = ['全部','中國國民黨','中華救助總會','婦聯會','救國團','民眾服務社','中央日報社','三中案','革實院','黨營事業','世亞盟','松山油漆廠']
  if in_type not in type_list:
    print("請重新輸入主題分類")
    return get_type()
  else:
    return in_type

def read_stories(a_type):
  # 讀取史料故事
  # 讀取Google雲端資料表
  sheetUrl = 'https://docs.google.com/spreadsheets/d/1ayhAdNJ_Tc9-6ptEkCZSQe-GJ0obpZoAsHvXIUVFOK4/edit#gid=37926428'
  sheetUrl = sheetUrl.replace('/edit#gid=', '/export?format=csv&gid=')
  storiesDf = pd.read_csv(sheetUrl)
  # 清理字詞跟切詞
  def clean(s):
    import re
    reg = re.compile("[A-Za-z\\d\-)(?=|$【（：:）】《，》。≠、」「•；,.]")  
    s = re.sub(reg, string=s, repl="") 
    reg = re.compile("https?\S+(?=\s|$)")
    s = re.sub(reg, string=s, repl = "")
    s = s.lower()
    s = s.replace("\r","")
    s = s.replace("\n","")
    s = s.replace("\t", "")
    s = s.replace("\\", "")
    s = s.replace("/", "")
    s = s.replace("\xa0","")
    return s
  storiesDf["內文_c"] = storiesDf["內文"].apply(clean)

  articles = []
  if a_type == '全部':
    for article in storiesDf["內文_c"]:
      articles.append(article)
    print('全部有' + str(len(articles)) + '篇文章')
    return articles
  else:
    for article in storiesDf[storiesDf['分類'] == a_type]["內文_c"]:
      articles.append(article)
    print(a_type + '有' + str(len(articles)) + '篇文章')
    return a_type, articles

"""## 繪製網絡圖"""

def drawnetworks(doc_list):
  # 讀取人名清單程式碼
  # 讀取Google雲端資料表(不當黨產相關名詞詞庫->整理人名清單)
  sheetUrl = 'https://docs.google.com/spreadsheets/d/1ayhAdNJ_Tc9-6ptEkCZSQe-GJ0obpZoAsHvXIUVFOK4/edit#gid=1085338611'
  sheetUrl = sheetUrl.replace('/edit#gid=', '/export?format=csv&gid=')
  personDf = pd.read_csv(sheetUrl)
  # 轉為Dict
  personDict = dict()
  for _, row in personDf.iterrows():
      if personDict.get(row['synonym']):
          personDict[row['synonym']].append(row['word'])
      else:
          personDict[row['synonym']] = [row['word']]
  # 建立人物關係
  people_assoc_dictionary = dict()
  # 走過每一篇文章
  for article in doc_list[1]:
      appears = []
      # 走過每一個人物
      for person in personDict:
      # 走過每一個人的許多別稱
        for name in personDict[person]:
            # 如果有出現在文章內就加入list
            if name in article:
                appears.append(person)
                break
      #利用 itertools.combinations 將list的名單進行排列組合，會自動排除重複值
      relationships = itertools.combinations(sorted(appears),2)
      #走過每一條關係，存到關係字典中，如果不同文章中都有關係就會累計
      for relationship in relationships:
          if relationship in people_assoc_dictionary:
              people_assoc_dictionary[relationship] += 1
          else:
              people_assoc_dictionary[relationship] = 1
  # 建立隨機網絡點位
  import plotly.graph_objects as go
  import networkx as nx
  G_ran = nx.random_geometric_graph(len(personDict), 0)
  G = nx.Graph()
  # 把人物存到node
  for person, i in zip(personDict, range(len(personDict))):
      G.add_node(person,pos = (G_ran.nodes[i]['pos'][0], G_ran.nodes[i]['pos'][1]))
  # 把關係存到edge(keys 有兩個點, values 就是關係出現次數)
  for edge, weight in people_assoc_dictionary.items():
      G.add_edge(edge[0], edge[1], weight=weight)
  # 抓出關係出現次數,除以文章篇數,乘上多少倍取決於輸出結果,我們當作加權強度
  edges = G.edges()
  weights = [G[u][v]['weight'] / len(doc_list[1]) * 30 for u,v in edges]

  # 使用plotly
  # 記錄線的座標
  edge_x = []
  edge_y = []
  for edge in G.edges():
      x0, y0 = G.nodes[edge[0]]['pos']
      x1, y1 = G.nodes[edge[1]]['pos']
      edge_x.append(x0)
      edge_x.append(x1)
      edge_x.append(None)
      edge_y.append(y0)
      edge_y.append(y1)
      edge_y.append(None)
  # 記錄線的外觀
  edge_trace = go.Scatter(
      x=edge_x, y=edge_y,
      line=dict(width=0.5, color='gainsboro'),
      hoverinfo='none',
      mode='lines')
  # 記錄點的座標
  node_x = []
  node_y = []
  for node in G.nodes():
      x, y = G.nodes[node]['pos']
      node_x.append(x)
      node_y.append(y)
  # 記錄點的外觀
  node_trace = go.Scatter(
      x=node_x, y=node_y,
      mode='markers',
      hoverinfo='text',
      marker=dict(
          showscale=True,
          colorscale='ice',
          reversescale=True,
          color=[],
          size=10,
          colorbar=dict(
              thickness=15,
              title='結點連結人數',
              xanchor='left',
              titleside='right'
          ),
          line_width=2))
  node_adjacencies = []
  node_text = []
  for node, adjacencies in enumerate(G.adjacency()):
      node_adjacencies.append(len(adjacencies[1]))
      node_text.append( adjacencies[0] + '的連結人數: '+ str(len(adjacencies[1])))
  # 繪圖
  node_trace.marker.color = node_adjacencies
  node_trace.text = node_text
  fig = go.Figure(data=[edge_trace, node_trace],
              layout=go.Layout(
                  title= doc_list[0] + '中的人物網絡圖',
                  titlefont_size=16,
                  showlegend=False,
                  hovermode='closest',
                  margin=dict(b=20,l=5,r=5,t=40),
                  height=900, width=1300, 
                  annotations=[ dict(
                      text="",
                      showarrow=False,
                      xref="paper", yref="paper",
                      x=0.005, y=-0.002 ) ],
                  xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                  yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                  )
  fig.show()

  # 讀取組織清單程式碼
  # 讀取Google雲端資料表(不當黨產相關名詞詞庫->整理組織清單)
  sheetUrl = 'https://docs.google.com/spreadsheets/d/1ayhAdNJ_Tc9-6ptEkCZSQe-GJ0obpZoAsHvXIUVFOK4/edit#gid=806375080'
  sheetUrl = sheetUrl.replace('/edit#gid=', '/export?format=csv&gid=')
  orgDf = pd.read_csv(sheetUrl)
  # 轉為Dict
  orgDict = dict()
  for _, row in orgDf.iterrows():
      if orgDict.get(row['synonym']):
          orgDict[row['synonym']].append(row['word'])
      else:
          orgDict[row['synonym']] = [row['word']]
  # 建立機構關係
  org_assoc_dictionary = dict()

  for article in doc_list[1]:
      appears = []
      for org in orgDict:
        for name in orgDict[org]:
            if name in article:
                appears.append(org)
                break
      relationships = itertools.combinations(sorted(appears),2)
      for relationship in relationships:
          if relationship in org_assoc_dictionary:
              org_assoc_dictionary[relationship] += 1
          else:
              org_assoc_dictionary[relationship] = 1
  #隨機網絡點位
  import plotly.graph_objects as go
  import networkx as nx
  G_ran = nx.random_geometric_graph(len(orgDict), 0)

  G = nx.Graph()
  for org,i in zip(orgDict, range(len(orgDict))):
      G.add_node(org,pos = (G_ran.nodes[i]['pos'][0], G_ran.nodes[i]['pos'][1]))
  for edge, weight in org_assoc_dictionary.items():
      G.add_edge(edge[0], edge[1], weight=weight)
  edges = G.edges()
  weights = [G[u][v]['weight'] / len(doc_list[1]) * 30 for u,v in edges]

  # 使用plotly
  # 記錄線的座標
  edge_x = []
  edge_y = []
  for edge in G.edges():
      x0, y0 = G.nodes[edge[0]]['pos']
      x1, y1 = G.nodes[edge[1]]['pos']
      edge_x.append(x0)
      edge_x.append(x1)
      edge_x.append(None)
      edge_y.append(y0)
      edge_y.append(y1)
      edge_y.append(None)
  # 記錄線的外觀
  edge_trace = go.Scatter(
      x=edge_x, y=edge_y,
      line=dict(width=0.5, color='gainsboro'),
      hoverinfo='none',
      mode='lines')
  # 記錄點的座標
  node_x = []
  node_y = []
  for node in G.nodes():
      x, y = G.nodes[node]['pos']
      node_x.append(x)
      node_y.append(y)
  # 記錄點的外觀
  node_trace = go.Scatter(
      x=node_x, y=node_y,
      mode='markers',
      hoverinfo='text',
      marker=dict(
          showscale=True,
          colorscale='ice',
          reversescale=True,
          color=[],
          size=10,
          colorbar=dict(
              thickness=15,
              title='結點連結人數',
              xanchor='left',
              titleside='right'
          ),
          line_width=2))
  node_adjacencies = []
  node_text = []
  for node, adjacencies in enumerate(G.adjacency()):
      node_adjacencies.append(len(adjacencies[1]))
      node_text.append( adjacencies[0] + '的連結人數: '+ str(len(adjacencies[1])))
  # 繪圖
  node_trace.marker.color = node_adjacencies
  node_trace.text = node_text
  fig = go.Figure(data=[edge_trace, node_trace],
              layout=go.Layout(
                  title= doc_list[0] + '中的機構網絡圖',
                  titlefont_size=16,
                  showlegend=False,
                  hovermode='closest',
                  margin=dict(b=20,l=5,r=5,t=40),
                  height=900, width=1300, 
                  annotations=[ dict(
                      text="",
                      showarrow=False,
                      xref="paper", yref="paper",
                      x=0.005, y=-0.002 ) ],
                  xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                  yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                  )
  fig.show()

drawnetworks(read_stories(get_type()))